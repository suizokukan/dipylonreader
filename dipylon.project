################################################################################
SOMMAIRE
################################################################################

[0] travail en cours

[1] options de compilation
    [1.1] options choisies pour le projet
    [1.2] article à propos des options de compilation

[2] style de code
    [2.0] conventions
    [2.1] range-based for loop
    [2.2] nullptr
    [2.3] tuple type

[3] particularités du c++11
    [3.0] doc
    [3.1] le casting
    [3.2] où se trouve l'include pour...
    [3.3] debugging

[4] particularités de Qt(5)
[4.1] comment lire un fichier multimédia

[5] découpage audio

[6] files and directory

################################################################################
[0] travail en cours
################################################################################

0.1.9 : à partir de http://qt-project.org/doc/qt-5/qtwidgets-mainwindows-application-example.html
        construire l'interface graphique de base

0.2.0 mode 1 : karaoke

      _ref > non, directement
      format du mode karaoke -> constante
      conserver la position des caractères surlignés
      
0.2.0 : XML 
http://qt-project.org/doc/qt-5/qtxml-xmlstreamlint-example.html
http://qt-project.org/doc/qt-5/qxmlstreamreader.html#details

################################################################################
[1] options de compilation
################################################################################

################################################################################
[1.1] options choisies pour le projet
################################################################################

Voir l'article en [1.2] : presque toutes les options en ont été reprises :
o l'option "-Wmissing-declarations" a été abandonnée car elle entrait en conflit avec le code automatiquement généré par Qt.

options du projet :

-pedantic -Wall -Wextra -Wcast-align -Wcast-qual -Wctor-dtor-privacy -Wdisabled-optimization -Wformat=2 -Winit-self -Wlogical-op -Wmissing-include-dirs -Wnoexcept -Wold-style-cast -Woverloaded-virtual -Wredundant-decls -Wshadow -Wsign-conversion -Wsign-promo -Wstrict-null-sentinel -Wstrict-overflow=5 -Wswitch-default -Wundef -Werror -Wno-unused

################################################################################
[1.2] article à propos des options de compilation

http://stackoverflow.com/questions/5088460/flags-to-enable-thorough-and-verbose-g-warnings/9862800
################################################################################

-pedantic -Wall -Wextra -Wcast-align -Wcast-qual -Wctor-dtor-privacy -Wdisabled-optimization -Wformat=2 -Winit-self -Wlogical-op -Wmissing-declarations -Wmissing-include-dirs -Wnoexcept -Wold-style-cast -Woverloaded-virtual -Wredundant-decls -Wshadow -Wsign-conversion -Wsign-promo -Wstrict-null-sentinel -Wstrict-overflow=5 -Wswitch-default -Wundef -Werror -Wno-unused

Questionable warnings that are present:

    I include -Wno-unused because I often have variables that I know I will use later, but do not yet have the functionality written for. Removing warnings about that allows me to write in my preferred style of occasionally deferring the implementation of things. It is useful to turn that off every once in a while to make sure nothing slipped through the cracks.

    -Wdisabled-optimization seems like a strong user-preference setting. I just added this one to my build (only for optimized builds for obvious reasons) and it didn't turn anything up, so it doesn't seem to be an especially chatty warning, at least for the way I code. I include it (even though code that triggers this warning isn't necessarily wrong) because I believe in working with my tools instead of against them. If gcc is telling me that it cannot optimize code for the way I wrote it, then I should look at rewriting it. I suspect that code that triggers this warning could benefit from being more modular, regardless, so although the code is not technically wrong (probably), stylistically it likely is.

    -Wfloat-equal warns for safe equality comparisons (in particular, comparison with a non-computed value of -1). An example in my code where I use this is that I have a vector of float. I go through this vector, and there are some elements I cannot evaluate yet what they should be, so I set them to -1.0f (since my problem only uses positive numbers, -1 is out of the domain). I later go through and update -1.0f values. It does not easily lend itself to a different method of operation. I suspect that most people don't have this problem, and comparison of an exact number in floating point is probably an error, so I'm including it in the default list.

    -Wold-style-cast has a lot of false positives in library code I'm using. In particular, the htonl family of functions used in networking, as well as a Rijndael (AES) encryption implementation I'm using has old-style casts that it warns me about. I intend to replace both of these, but I'm not sure if there is anything else in my code that it will complain about. Most users should probably have this on by default, though.

    -Wsign-conversion was a tough one (and almost didn't make the list). Turning it on in my code generated a huge amount of warnings (100+). Almost all of them were innocent. However, I have been careful to use signed integers wherever I wasn't sure, although for my particular problem domain, I would usually get a slight efficiency increase using unsigned values due to the large amount of integer division I do. I sacrificed this efficiency because I was concerned about accidentally promoting a signed integer to an unsigned and then dividing (which is not safe, unlike addition, subtraction, and multiplication). Turning on this warning allowed me to safely change most of my variables to unsigned types and add a few casts in some other places. It's currently a little hard to use because the warning isn't that smart. For instance, if you do unsigned short + (integral constant expression), that result is implicitly promoted to int. It then warns about a potential sign problem if you assign that value to unsigned or unsigned short, even though it's safe. This is definitely the most optional warning for almost all users.

    -Wsign-promo: see -Wsign-conversion.

    -Wswitch-default seems pointless (you don't always want a default case if you've enumerated all possibilities explicitly). However, turning on this warning can enforce something that is probably a good idea. For cases where you explicitly want to ignore everything except the listed possibilities (but other numbers are possible), then put in default: break; to make it explicit. If you explicitly enumerate all possibilities, then turning on this warning will help ensure that you put something like assert (false) to make sure that you've actually covered all possible options. It lets you be explicit in what the domain of your problem is and programatically enforces that. However, you'll have to be careful in just sticking assert (false) everywhere. It's better than doing nothing with the default case, but as usual with assert, it won't work in release builds. In other words, you cannot rely on it to validate numbers that you get from, say, a network connection or a database that you do not have absolute control over. Exceptions or returning early are the best way to handle that (but still require you to have a default case!).

    -Werror is an important one for me. When compiling large amounts of code in a multi-threaded build with multiple targets, it's easy for a warning to slip by. Turning warnings into errors ensures that I notice them.

Then there is a set of warnings that are not included in the above list because I did not find them to be useful. These are the warnings and my comments on why I'm not including them in the default list:

Warnings that are absent:

    -Wabi is not needed because I'm not combining binaries from different compilers. I tried compiling with it anyway, and it didn't trigger, so it doesn't seem needlessly verbose.

    -Waggregate-return is not something that I consider an error. For instance, it triggers when using a range-based for loop on a vector of classes. Return value optimization should take care of any negative effects of this.

    -Wconversion triggers on this code: short n = 0; n += 2; The implicit conversion to int causes a warning when it's then converted back to its target type.

    -Weffc++ includes a warning if all data members are not initialized in the initializer list. I intentionally do not do this in many cases, so the set of warnings is too cluttered to be useful. It's helpful to turn on every once in a while and scan for other warnings, though (such as non-virtual destructors of base classes). This would be more useful as a collection of warnings (like -Wall) instead of a single warning on its own.

    -Winline is absent because I don't use the inline keyword for optimization purposes, just to define functions inline in headers. I don't care if the optimizer actually inlines it. This warning also complains if it can't inline a function declared in a class body (such as an empty virtual destructor).

    -Winvalid-pch is missing because I don't use precompiled headers.

    -Wmissing-format-attribute is not used because I do not use gnu extensions. Same for -Wsuggest-attribute and several others

    Potentially notable for its absence is -Wno-long-long, which I have no need for. I compile with -std=c++0x (-std=c++11 in GCC 4.7), which includes long long integer types. Those stuck back on C++98 / C++03 may consider adding that exclusion from the warning list.

    -Wnormalized=nfc is already the default option, and looks to be the best.

    -Wpadded is turned on occasionally to optimize the layout of classes, but it is not left on because not all classes have enough elements to remove padding at the end. In theory I could get some extra variables for 'free', but it's not worth the extra effort of maintaining that (if my class size changes, it's not easy to remove those previously free variables).

    -Wstack-protector is not used because I do not use -fstack-protector

    -Wstrict-aliasing=3 is turned on by -Wall and is the most accurate, but it looks like level 1 and 2 give more warnings. In theory a lower level is a 'stronger' warning, but it's at the cost of more false positives. My own test code compiled cleanly under all 3 levels.

    -Wswitch-enum isn't behavior that I want. I don't want to handle every switch statement explicitly. It would be useful if the language had some mechanism to activate this on specified switch statements (to ensure that future changes to the enum are handled everywhere that they need to be), but it's overkill for an "all-or-nothing" setting.

    -Wunsafe-loop-optimizations causes too many spurious warnings. It may be useful to apply this one periodically and manually verify the results. As an example, it generated this warning in my code when I looped over all elements in a vector to apply a set of functions to them (using the range-based for loop). It is also warning for the constructor of a const array of const std::string (where this is no loop in user code).

    -Wzero-as-null-pointer-constant and -Wuseless-cast are GCC-4.7-only warnings, which I will add when I transition to GCC 4.7.

################################################################################
[2] style de code
################################################################################

[2.0] conventions
* les pointeurs doivent être déclarés initialiés à null_ptr
* un fichier XXX.cpp ne peut avoir qu'un seul include si le fichier XXX.h existe. main.cpp n'est donc pas concerné.
* pour les includes : d'abord les miens, ceux de la STD, ensuite ceux de Qt.

################################################################################
[2.1] range-based for loop

en.wikipedia.org/wiki/C%2B%2B11
################################################################################

int my_array[5] = {1, 2, 3, 4, 5};
for (auto &x : my_array) {
    x *= 2;
}

################################################################################
[2.2] nullptr

en.wikipedia.org/wiki/C%2B%2B11
################################################################################

char *pc = nullptr;     // OK
int  *pi = nullptr;     // OK
bool   b = nullptr;     // OK. b is false.

################################################################################
[2.3] tuple type

en.wikipedia.org/wiki/C%2B%2B11
################################################################################

typedef std::tuple <int, double, long &, const char *> test_tuple;
long lengthy = 12;
test_tuple proof (18, 6.5, lengthy, "Ciao!");
 
lengthy = std::get<0>(proof);  // Assign to 'lengthy' the value 18.
std::get<3>(proof) = " Beautiful!";  // Modify the tuple’s fourth element.

################################################################################
[3] particularités du c++11
################################################################################

################################################################################
[3.0] doc
################################################################################
FAQ C++ : http://www.parashift.com/c++-faq-lite/index.html

################################################################################
[3.1] le casting

http://stackoverflow.com/questions/332030
################################################################################

static_cast is the first cast you should attempt to use. It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating static_cast isn't necessary, but it's important to note that the T(something) syntax is equivalent to (T)something and should be avoided (more on that later). A T(something, something_else) is safe, however, and guaranteed to call the constructor.

static_cast can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn't cast through virtual inheritance. It does not do checking, however, and it is undefined behavior to static_cast down a hierarchy to a type that isn't actually the type of the object.

const_cast can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even reinterpret_cast). It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn't declared with const, it is safe. This can be useful when overloading member functions based on const, for instance. It can also be used to add const to an object, such as to call a member function overload.

const_cast also works similarly on volatile, though that's less common.

dynamic_cast is almost exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards -- you can cast sideways or even up another chain. The dynamic_cast will seek out the desired object and return it if possible. If it can't, it will return NULL in the case of a pointer, or throw std::bad_cast in the case of a reference.

dynamic_cast has some limitations, though. It doesn't work if there are multiple objects of the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using virtual inheritance. It also can only go through public inheritance - it will always fail to travel through protected or private inheritance. This is rarely an issue, however, as such forms of inheritance are rare.

reinterpret_cast is the most dangerous cast, and should be used very sparingly. It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things. Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type). There are a number of conversions that reinterpret_cast cannot do, too. It's used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer.

################################################################################
[3.2] où se trouve l'include pour...
################################################################################

std::pair               : #include <utility>
std::initializer_list   : #include <initializer_list>

Qt :
qint64                  : #include <QtGlobal>

################################################################################
[3.3] debugging
################################################################################

typeid(src_i).name()

################################################################################
[4] particularités de Qt(5)
################################################################################

################################################################################
[4.1] comment lire un fichier multimédia
################################################################################

sous Linux, Qt5 utilise gstreamer0.10 (PAS une version plus récente); pour un ogg, gstreamer-ffmeg est nécessaire.

################################################################################
[4.2] Qt et les destructors
################################################################################
http://stackoverflow.com/questions/1436904/destructors-in-qt4/1439219#1439219

Qt uses what they call object trees and it's a bit different from the typical RAII approach.

The QObject class constructor takes a pointer to a parent QObject. When that parent QObject is destructed, its children will be destroyed as well. This is a pretty prevalent pattern throughout Qt's classes and you'll notice a lot of constructors accept a *parent parameter.

################################################################################
[5] découpage audio
################################################################################

utiliser le format .ogg
Audacity
lire le texte rapidement sans temps mort entre les segments.

################################################################################
[6] files and directory
################################################################################

dipylon/                                            C++/Qt5 code
       /dipylon.sh                                  compiler, launcher

dipylon/dipydoc/                                    DipylonDocument
               /dipydoc.[h|cpp]                     DipyDoc class

dipylon/misc/
	    /hash.[h|cpp]                           generic hash function

dipylon/pos/
	   /posintext/
                     /posintext.h                   PosInText declaration
                     /posintext2str.[h|cpp]         PosInText2Str class
                     /posintextranges.[h|cpp]       PosInTextRanges class
                     /vectorposintextranges.[h|cpp] VectorPosInTextRanges class

dipylon/qt/                                         Qt5 / UI code
          /dipylonui.[h|cpp]                        UI definition
          /commentaryeditor.[h|cpp]                 commentary zone
          /mainsplitter.[h|cpp]                     splitter between commentary and source zone
	  /mainwindow.[h|cpp]                       MainWindow class
          /sourceeditor.[h|cpp]                     source zone

dipylon/tests/
	     /testhash..[h|cpp]		            test of the hash function defined misc/hash.h
	     /testposintext2str.[h|cpp]		    test of the PosInText2Str class
	     /testposintextranges.[h|cpp]	    test of the PosInTextRanges class
	     /testvectorposintextranges.[h|cpp]	    test of the VectorPosInTextRanges class
	     /tests.cpp				    entry point for the tests